# 整型对象
在Python2.5中整型对象在intobject.c中， 而在Python3.6中，改为在longobject.c中实现。

当我看到源码的第一行时，惊呆了：

![Python支持任意精度的整数，除非你的内存不够！](../image/longobject.png)

换句话说，当你计算两个大整数的乘法时，一行代码就可以搞定！

单凭这一点，是否已经勾引起你的兴趣了呢？

# 整型对象定义
    typedef uint32_t digit;  /* digit的定义，取决于PYLONG_BITS_IN_DIGIT的值， 此外暂以unint32_t来分析代码*/
    struct _longobject {
        PyObject_VAR_HEAD
        digit ob_digit[1];
    };
So easy!  但是如果你阅读过Python2.5代码，你会发现，在Python3.6中，longobject不再是定长对象了。这就是它支持任意精度的秘密！

从结构体定义来看， 就是对ob_digit封装了一层。

# 整型的类型对象
    PyTypeObject PyLong_Type = {
        PyVarObject_HEAD_INIT(&PyType_Type, 0)
        "int",                                      /* tp_name */
        offsetof(PyLongObject, ob_digit),           /* tp_basicsize */
        sizeof(digit),                              /* tp_itemsize */
        long_dealloc,                               /* tp_dealloc */
        0,                                          /* tp_print */
        0,                                          /* tp_getattr */
        0,                                          /* tp_setattr */
        0,                                          /* tp_reserved */
        long_to_decimal_string,                     /* tp_repr */
        &long_as_number,                            /* tp_as_number */
        0,                                          /* tp_as_sequence */
        0,                                          /* tp_as_mapping */
        (hashfunc)long_hash,                        /* tp_hash */
        0,                                          /* tp_call */
        long_to_decimal_string,                     /* tp_str */
        PyObject_GenericGetAttr,                    /* tp_getattro */
        0,                                          /* tp_setattro */
        0,                                          /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
            Py_TPFLAGS_LONG_SUBCLASS,               /* tp_flags */
        long_doc,                                   /* tp_doc */
        0,                                          /* tp_traverse */
        0,                                          /* tp_clear */
        long_richcompare,                           /* tp_richcompare */
        0,                                          /* tp_weaklistoffset */
        0,                                          /* tp_iter */
        0,                                          /* tp_iternext */
        long_methods,                               /* tp_methods */
        0,                                          /* tp_members */
        long_getset,                                /* tp_getset */
        0,                                          /* tp_base */
        0,                                          /* tp_dict */
        0,                                          /* tp_descr_get */
        0,                                          /* tp_descr_set */
        0,                                          /* tp_dictoffset */
        0,                                          /* tp_init */
        0,                                          /* tp_alloc */
        long_new,                                   /* tp_new */
        PyObject_Del,                               /* tp_free */
    };
其中，所支持的整数操作有：

    static PyNumberMethods long_as_number = {
        (binaryfunc)long_add,       /*nb_add*/
        (binaryfunc)long_sub,       /*nb_subtract*/
        (binaryfunc)long_mul,       /*nb_multiply*/
        long_mod,                   /*nb_remainder*/
        long_divmod,                /*nb_divmod*/
        long_pow,                   /*nb_power*/
        (unaryfunc)long_neg,        /*nb_negative*/
        (unaryfunc)long_long,       /*tp_positive*/
        (unaryfunc)long_abs,        /*tp_absolute*/
        (inquiry)long_bool,         /*tp_bool*/
        (unaryfunc)long_invert,     /*nb_invert*/
        long_lshift,                /*nb_lshift*/
        (binaryfunc)long_rshift,    /*nb_rshift*/
        long_and,                   /*nb_and*/
        long_xor,                   /*nb_xor*/
        long_or,                    /*nb_or*/
        long_long,                  /*nb_int*/
        0,                          /*nb_reserved*/
        long_float,                 /*nb_float*/
        0,                          /* nb_inplace_add */
        0,                          /* nb_inplace_subtract */
        0,                          /* nb_inplace_multiply */
        0,                          /* nb_inplace_remainder */
        0,                          /* nb_inplace_power */
        0,                          /* nb_inplace_lshift */
        0,                          /* nb_inplace_rshift */
        0,                          /* nb_inplace_and */
        0,                          /* nb_inplace_xor */
        0,                          /* nb_inplace_or */
        long_div,                   /* nb_floor_divide */
        long_true_divide,           /* nb_true_divide */
        0,                          /* nb_inplace_floor_divide */
        0,                          /* nb_inplace_true_divide */
        long_long,                  /* nb_index */
    };

如何能够支持任意精度呢？

# 整型创建与销毁
整型对象是程序中最常用对象之一。对于Python来说，对象的创建与销毁均需要在堆上进行申请与释放。所以这必然会导致效率的低下。而且也会导致内存产生大量的碎片。
另一个解决问题的极端方法是，所以整数对象一次申请，并不释放。虽然很大程度上提高了效率，但是内存利用率是无法忍受的。因此Gui叔把整数分为两部分，小整数和普通整数。
* 对于小整数来说，一次申请，但不释放
* 对于普通整数则一次申请，一次“释放”（这里并不是真正的释放内存！）

# 走进大师
分析 一下 大数相乘 代码，并分析其算法复杂度。




